<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Dunitearth - DUniter peers viewer - three.js webgl</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			three-renderer {
				display: block;
				width: 100%;
				height: 100%;
			}

			a {
				color: #0080ff;
			}
			menu {
				position: absolute;
				bottom: 0;
			}
		</style>
		<style>
			.dg.main {
				/*text-transform: uppercase;*/
				color: grey;
				font-weight: bolder;
			}
			
			.dg .c select,
			.dg li.save-row select {
				background-color: #303030;
				color: white;
						border: none;
				
			}
			.dg .c select {
				width: 100%;
			}
			
			.dg li:not(.folder) {
				borer: none;
			}
				.dg li.save-row {
					background: none;
				}
					.dg li.save-row select {
					}
					.dg li.save-row .button.gears {
						background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==);
						background-repeat: no-repeat;
						background-position: 2px 1px;
					}
					.dg li.save-row .button,
					.dg li.save-row .button.gears {
						background-color: #303030;
						text-shadow: none;
						box-shadow: none;
						border-radius: 0;
					}
			.dg .slider {
				height: 8px;
				border-radius: 4px;
			}
			.dg .c .slider-fg {
				border-radius: 4px;
			}
			.dg .c input[type=text] {
				box-sizing: border-box;
			}
			
			
			/* colors */
			
			.dg .c .slider-fg {
				background: #2fa1d6;
			}
			.dg .cr.string { border-left: 3px solid #1ed36f; }
			.dg .cr.string input[type=text] { color: #1ed36f; }
		</style>
		
		<script src="js/libs/dat.gui.min.js"></script>
		
		<script src="build/three.js"></script>
		<script src="js/three.elements.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src='js/threex.earth.js'></script>
		<script src="js/three-text2d/dist/text2d.js"></script>

		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/tween.min.js"></script>
		<script src="js/libs/cannon.min.js"></script>
		
		<script src="dun/DUniter.js"></script>
		
	</head>
	<body>
		
		<menu>
			<button onclick="test_net.play(0,document.querySelector('#quick-mode').checked)">PLAY</button>
			<input id="quick-mode" type="checkbox" checked="checked"/>QUICK MODE
			<button onclick="test_net.stop()">STOP</button>
			<button onclick="test_net.reset()">RESET</button>
			<span id="block-number"></span>
		</menu>
		
		<three:renderer auto-render="true" onready="init()" onrender="" onanimate="">
			<script type="event/onReady">
				var renderer = event.renderer;
				
				var NEAR = 0.01, FAR = 20000;
				var SHADOW_MAP_WIDTH = 512;
				var SHADOW_MAP_HEIGHT = 512;
				
				var plane = new THREE.Plane();
				var raycaster = new THREE.Raycaster();
				var mouse = new THREE.Vector2(),
					offset = new THREE.Vector3(),
					intersection = new THREE.Vector3(),
					INTERSECTED, SELECTED;
				
				// window['First peer to connect'] = "http://cgeek.fr:9330/";
				window['First peer to connect'] = "http://peer.duniter.org:8999/";
				window.Connect = function()
				{
					window.test_net = new DUniterBlockchain( window['First peer to connect'] );
					
					setTimeout( ()=>
						test_net._accounts
							.filter((t,i)=>i<10)
							.map((m,i) => scene.add(new MemberIcon(m,i)) )
					, 5000);
					// return;
					test_net.addEventListener( 'peerAdded', e => {
						
						// console.log( e.peer );
						e.peer.addEventListener('locationFound', e2 => {
							
							var loc = e2.endpoint.location,
								ep = e2.endpoint;
							
							var marker = new THREEx.Planets.EarthMarker( loc.latitude, loc.longitude );
							marker.pointer.material = new THREE.MeshBasicMaterial({color:0xFF0000});
							marker.pointer.material.color = e.peer.status == 'UP' ? new THREE.Color(0x00FF00) :  new THREE.Color(0xFF0000);
							system.earth.add( marker );
							
							var label = ep.ip + (ep.domain ? ' (' + ep.domain + ')' : '');
							
							var curFold = leftMenu.__folders["Network"].__folders[e.peer.currency] || leftMenu.__folders["Network"].addFolder( e.peer.currency );
							
							var fold = curFold.addFolder( label );
							// fold.__ul.firstChild.style.backgroundColor = e.peer.status == 'UP' ? 'rgba(20,88,8,0.3)' : 'rgba(95,16,16,0.3)';
							fold.__ul.firstChild.style.backgroundColor = e.peer.status == 'UP' ? '#145808' : '#5f1010';
							fold.add(e2.endpoint.location, 'city').__input.disabled = true;
							fold.add(e2.endpoint.location, 'region').__input.disabled = true;
							fold.add(e2.endpoint.location, 'country').__input.disabled = true;
							fold.add(e2.endpoint.location, 'postal').__input.disabled = true;
							fold.add(e2.endpoint.location, 'hostname').__input.disabled = true;
							fold.add(e2.endpoint.location, 'org').__input.disabled = true;
							fold.add(e2.endpoint, 'domain').__input.disabled = true;
							fold.add(e.peer, 'status').__input.disabled = true;
							
							// debugger;
							curFold.__ul.firstChild.innerText = e.peer.currency + ' (' +
							curFold.__ul.querySelectorAll('.folder').length
							
							+ ')';
						});
						
					})
				}
				function initGUI() {
	
					window.leftMenu = new dat.GUI();
					leftMenu.domElement.style.float = 'left';
					// leftMenu.domElement.style.marginLeft =  '15px';
					window.rightMenu = new dat.GUI();
					// document.body.appendChild( leftMenu );
					
					var ren = rightMenu.addFolder( "Render" )
						
						ren.addColor( {color:'#000000' }, "color" ).name( 'Background' )
							.onChange( v => renderer.renderer.setClearColor(new THREE.Color(v)) ) 
						ren.add( system.stars, "visible" ).name( 'Show stars' )
						
						// ren.add( {"Background":"stars"}, "Background", [
			//				 "stars", 
			//				 "color"
						// ]).onChange( value => { 
								
						//	 }) 
						
						ren.add( {"Earth style":"earthmap"}, "Earth style", {
							"water":'earth_bath_3600x1800_color.jpg', 
							"simple":'earthmap_no_clouds_4k.jpg',
							"blueprints":'earthmap-blueprints.jpg',
							"digital":'earthmap-digital.jpg',
							"geometric":'earthmap-geometric.jpg',
							"grey":'earthmap-grey.jpg',
							"mesh":'earthmap-mesh.jpg',
							"pencil":'earthmap-pencil.jpg',
							"rusty":'earthmap-rusty.jpg',
							"colours":'earthmap-water-colour.jpg',
						}).onChange( value => { 
								system.earth.loader.load(
									THREEx.Planets.baseURL + value, 
									texture => {
										system.earth.material.map = texture;
										system.earth.material._needsUpdate = true
									}
								)
							}) 
						ren.add( system.earth, "highDefinition" )
						ren.add( system.earth, "atmosphere" ).name( 'Show atmosphere' )
						ren.add( system.earth.clouds, "visible" ).name( 'Show clouds' )
				// 		ren.add( system.earth.clouds, "visible" ).name( 'Show relief' )
						
						ren.add( system.sun, "visible" ).name( 'Show sun' ).onChange( value => { 
								system.ambient.visible = !value;
							}) 
				// 		ren.add( system.sun, "visible" ).name( 'Show moon' )
						// ren.add( system.earth, "atmosphere" )
						// ren.add( system.earth, "clouds" )
					ren.open()
					
					
					
					leftMenu.add( window, 'First peer to connect' )
					leftMenu.add( window, 'Connect' )
					
					Peer['Show DOWNs'] = true;
					var net = leftMenu.addFolder( "Network" )
						net.add( Peer, "Show DOWNs" )
					net.open()
					
					// var ren = gui.addFolder( "Render" );
					// ren.add( effectController, "showDots" ).onChange( function( value ) { pointCloud.visible = value; } );
					// ren.add( effectController, "showLines" ).onChange( function( value ) { linesMesh.visible = value; } );
					// ren.add( Member, "showVelocity" );
					// ren.add( Dune, "showBoundingBox" );
					// ren.open();
					
		//			 var phy = gui.addFolder( "Physics" );
		//				 var phy_wol = phy.addFolder('World');
		//				 phy_wol.open();
		//				 var phy_mem = phy.addFolder('Member');
		//	 				phy_mem.add( Member, "FRICTION", 1, 10 );
		//					 phy_mem.add( Member, "REPULSENESS", 0, 3 );
		//					 phy_mem.add( Member, "ATRACTIVENESS", 0, 3 );
					//		 phy_mem.add( Member, "DISTANCE", 10, 300 );
		//				 phy_mem.open();
		//				 var phy_dun = phy.addFolder('Dune');
		//	 				phy_dun.add( Dune, "GRAVITY", -1, 1 );
		//				 phy_dun.open();
		//			 phy.open();
					
		//			 var wot = gui.addFolder( "WoT" );
					// // wot.add( Dune.parameters, "dt", 10, 300 );
					// wot.open();
					
					// gui.add( effectController, "limitConnections" );
					// gui.add( effectController, "maxConnections", 0, 30, 1 );
					// gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {
	
					// 	particleCount = parseInt( value );
					// 	particles.setDrawRange( 0, particleCount );
	
					// });
	
				}
                
                
				window.scene = renderer.scene = 
				// new THREE.Scene();
				
				
				// var material	= new THREE.MeshBasicMaterial({
				//	 color	: new THREE.Color(0xFFFFFF),
				//	 side	: THREE.BackSide
				// })
				// var geometry	= new THREE.SphereGeometry(200, 32, 32)
				// var mesh	= new THREE.Mesh(geometry, material)
				// scene.add(mesh);
				
				
				
				
				
				
				
				
				
				
				
				
				window.system = 
				new THREEx.Planets.SolarSystem({
					stars: true,
					sun: true,
					earth: true
				})
				system.referencial = system.earth;
				
				// earth is 6371km radius so 1/63.71 make the earth size of 100
				system.scale.multiplyScalar(1/63.71);
			// 	camera.far = 150000000;
			// 	camera.updateProjectionMatrix();

				// window.camera = renderer.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, NEAR, FAR );
				window.camera = system.camera;
				camera.position.z=2000

				window.controls = renderer.controls = new THREE.OrbitControls( camera, renderer.domElement );

				
				// SCENE
				// window.scene = renderer.scene = new THREE.Scene();
				// scene.fog = new THREE.Fog( 0x222222, 1000, FAR );
				// scene.fog = new THREE.Fog( 0x111111, 1000, 2000 );
		
				// LIGHTS
				// ambient = new THREE.AmbientLight( 0xFFFFFF );
				// scene.add( ambient );
		
				// light = new THREE.SpotLight( 0xffffff );
				// light.position.set( 30, 30, 40 );
				// light.target.position.set( 0, 0, 0 );
		
				// light.castShadow = true;
		
			//	 light.shadowCameraNear = 10;
			//	 light.shadowCameraFar = 100;//camera.far;
			//	 light.shadowCameraFov = 30;
		
			//	 light.shadowMapBias = 0.0039;
			//	 light.shadowMapDarkness = 0.5;
			//	 light.shadowMapWidth = SHADOW_MAP_WIDTH;
			//	 light.shadowMapHeight = SHADOW_MAP_HEIGHT;
			//	 //light.shadowCameraVisible = true;
				// scene.add( light );
				
				
// 				light	= new THREE.DirectionalLight( 0xffffff, 1 )
// 				light.position.set(50,50,50)
// 				light.lookAt( scene.position )
// 				scene.add( light )
// 				light.castShadow	= true
// 				light.shadow.camera.near	= 0.01
// 				light.shadow.camera.far	= 15
// 				light.shadow.camera.fov	= 45
			
// 				light.shadow.camera.left	= -1
// 				light.shadow.camera.right	=  1
// 				light.shadow.camera.top	=  1
// 				light.shadow.camera.bottom= -1
// 				// light.shadowCameraVisible	= true
			
// 				light.shadow.bias	= 0.001
// 			// 	light.shadow.darkness	= 0.2
			
// 				light.shadow.mapSize.width	= 1024
// 				light.shadow.mapSize.height	= 1024
// 				scene.add( light );
				
// 				light	= new THREE.DirectionalLight( 0xffffff, 1 )
// 				light.position.set(-50,-50,-50)
// 				light.lookAt( scene.position )
// 				scene.add( light )
// 				light.castShadow	= true
// 				light.shadow.camera.near	= 0.01
// 				light.shadow.camera.far	= 15
// 				light.shadow.camera.fov	= 45
			
// 				light.shadow.camera.left	= -1
// 				light.shadow.camera.right	=  1
// 				light.shadow.camera.top	=  1
// 				light.shadow.camera.bottom= -1
// 				// light.shadowCameraVisible	= true
			
// 				light.shadow.bias	= 0.001
// 			// 	light.shadow.darkness	= 0.2
			
// 				light.shadow.mapSize.width	= 1024
// 				light.shadow.mapSize.height	= 1024
// 				scene.add( light );
				
				// window.test_net = new DUniterBlockchain( "http://cgeek.fr:9330/" );
				// test_net.addEventListener( 'peerAdded', e => {
					
				//	 console.log( e.peer );
				//	 e.peer.addEventListener('locationFound', e2 => {
						
				//		 var loc = e2.endpoint.location;
				//		 var marker = new THREEx.Planets.EarthMarker( loc.latitude, loc.longitude );
				//		 system.earth.add( marker );
						
				//		 var fold = leftMenu.__folders["Network"].addFolder( e2.endpoint.location.ip );
				//		 fold.add(e2.endpoint.location, 'city')
				//		 fold.add(e2.endpoint.location, 'region')
				//		 fold.add(e2.endpoint.location, 'country')
				//		 fold.add(e2.endpoint.location, 'postal')
				//		 fold.add(e2.endpoint.location, 'hostname')
				//		 fold.add(e2.endpoint.location, 'org')
				//		 fold.add(e2.endpoint, 'domain')
					
				//	 })
				// })
				
				
				// navigator.geolocation.watchPosition(function (pos) {
				//	 marker.coordinates = pos.coords;
				// });
				
				initGUI();
				
			</script>
			<script type="event/onAnimate">
				
				system.animate( event );
				
				window.test_net && test_net.animate( event );
				// dune.animate();
				
				TWEEN.update();
			</script>
			<script type="event/onRender">
				// dune._boundingBox.geometry &&
				// dune._boundingBox.geometry.boundingSphere &&
				// dune._boundingBox.geometry.boundingSphere.center &&
				//	 camera.lookAt( dune._boundingBox.geometry.boundingSphere.center );
				// camera.lookAt( MedianPosition( dune.children.filter( c => c instanceof Account ) ) );
				// group.rotation.y = time * 0.1;
				
				// camera.position.x = Math.sin( system.earth.rotation.y ) * 1000;
				// camera.position.z = Math.cos( system.earth.rotation.y ) * 1000;
				// camera.lookAt( system.earth.position );
				
			</script>
		</three:renderer>
		
		<script type="zz">
			
			
			var test_net, dune, earth, marker;
			var container, controls, stats;
			var world, camera, scene, renderer;
			var NEAR = 0.01, FAR = 20000;
			var SHADOW_MAP_WIDTH = 512;
			var SHADOW_MAP_HEIGHT = 512;
			
			var plane = new THREE.Plane();
			var raycaster = new THREE.Raycaster();
			var mouse = new THREE.Vector2(),
				offset = new THREE.Vector3(),
				intersection = new THREE.Vector3(),
				INTERSECTED, SELECTED;

			var effectController = {
					showDots: false
				,	showLines: false
				,	showFaces: false
				,	showVelocity: false
				,	distance: 100
				,	friction: 100
				};
			
// 			init();
			
			
// 			requestAnimationFrame( animate );
			
			function initGUI() {

				var gui = new dat.GUI();
				
				var ren = gui.addFolder( "Render" );
				ren.add( effectController, "showDots" ).onChange( function( value ) { pointCloud.visible = value; } );
				ren.add( effectController, "showLines" ).onChange( function( value ) { linesMesh.visible = value; } );
				ren.add( Member, "showVelocity" );
				ren.add( Dune, "showBoundingBox" );
				ren.open();
				
				var phy = gui.addFolder( "Physics" );
					var phy_wol = phy.addFolder('World');
					phy_wol.open();
					var phy_mem = phy.addFolder('Member');
						phy_mem.add( Member, "FRICTION", 1, 10 );
						phy_mem.add( Member, "REPULSENESS", 0, 3 );
						phy_mem.add( Member, "ATRACTIVENESS", 0, 3 );
						phy_mem.add( Member, "DISTANCE", 10, 300 );
					phy_mem.open();
					var phy_dun = phy.addFolder('Dune');
						phy_dun.add( Dune, "GRAVITY", -1, 1 );
					phy_dun.open();
				phy.open();
				
				var wot = gui.addFolder( "WoT" );
				// wot.add( Dune.parameters, "dt", 10, 300 );
				wot.open();
				
				// gui.add( effectController, "limitConnections" );
				// gui.add( effectController, "maxConnections", 0, 30, 1 );
				// gui.add( effectController, "particleCount", 0, maxParticleCount, 1 ).onChange( function( value ) {

				// 	particleCount = parseInt( value );
				// 	particles.setDrawRange( 0, particleCount );

				// });

			}

			function init() {

				initGUI();
				// initCannon();

				container = document.getElementsByTagName( 'renderer' )[0];

				//

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, NEAR, FAR );
				camera.position.z = 1750;

				controls = new THREE.OrbitControls( camera, container );

				
				// SCENE
				scene = new THREE.Scene();
				// scene.fog = new THREE.Fog( 0x222222, 1000, FAR );
				// scene.fog = new THREE.Fog( 0x111111, 1000, 2000 );
		
				// LIGHTS
				ambient = new THREE.AmbientLight( 0x222222 );
				scene.add( ambient );
		
				// light = new THREE.SpotLight( 0xffffff );
				// light.position.set( 30, 30, 40 );
				// light.target.position.set( 0, 0, 0 );
		
				// light.castShadow = true;
		
				// light.shadowCameraNear = 10;
				// light.shadowCameraFar = 100;//camera.far;
				// light.shadowCameraFov = 30;
		
				// light.shadowMapBias = 0.0039;
				// light.shadowMapDarkness = 0.5;
				// light.shadowMapWidth = SHADOW_MAP_WIDTH;
				// light.shadowMapHeight = SHADOW_MAP_HEIGHT;
				// //light.shadowCameraVisible = true;
				// scene.add( light );
				
				
				light	= new THREE.DirectionalLight( 0xffffff, 1 )
				light.position.set(5,5,5)
				scene.add( light )
				light.castShadow	= true
				light.shadow.camera.near	= 0.01
				light.shadow.camera.far	= 15
				light.shadow.camera.fov	= 45
			
				light.shadow.camera.left	= -1
				light.shadow.camera.right	=  1
				light.shadow.camera.top	=  1
				light.shadow.camera.bottom= -1
				// light.shadowCameraVisible	= true
			
				light.shadow.bias	= 0.001
			// 	light.shadow.darkness	= 0.2
			
				light.shadow.mapSize.width	= 1024
				light.shadow.mapSize.height	= 1024
		
				
				test_net = new DUniterBlockchain( "http://cgeek.fr:9330/" );
				test_net.addEventListener( 'peerAdded', e => {
					
					console.log( e.peer );
					e.peer.addEventListener('locationFound', e2 => {
						
						var loc = e2.endpoint.location;
						var marker = new THREEx.Planets.EarthMarker( loc.latitude, loc.longitude );
						earth.add( marker );
						
					
					})
				})
				
				scene.add(
					new THREEx.Planets.Starfield( FAR*0.95 )
				)
				
				scene.add(
					earth = new THREEx.Planets.Earth({
						atmosphere: true,
						clouds: true
					})
				);
				
				earth.scale.multiplyScalar(1/63.71)
				
				
				// marker = new THREEx.Planets.EarthMarker();
				
				// [initial position] rotate by lat/long
				// For ball is at (X,0,0), the lat rotation should be around Z axis
				// var rad = Math.PI / 180;
				// marker.quaternion.setFromEuler(
				//	 new THREE.Euler(0, 135 * rad, 45 * rad, "YZX")); 
				
				// earth.add( marker );
				
				// navigator.geolocation.watchPosition(function (pos) {
				//	 marker.coordinates = pos.coords;
				// });
				
				
				// Renderer

				// renderer = new THREE.WebGLRenderer( { antialias: true } );
				// renderer.setPixelRatio( window.devicePixelRatio );
				// renderer.setSize( window.innerWidth, window.innerHeight );
				// renderer.sortObjects = false;
				// renderer.shadowMapEnabled = true;

				// renderer.gammaInput = true;
				// renderer.gammaOutput = true;

				// container.appendChild( renderer.domElement );
				
				// Mouse
				
				container.domElement.addEventListener( 'touchstart', onDocumentTouchStart, false );
				container.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
				container.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
				container.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
				
				// Stats

				stats = new Stats();
				stats.dom.style.cssText = "position:fixed;bottom:0;right:0;cursor:pointer;opacity:0.9;z-index:10000";
				container.appendChild( stats.dom );

				// window.addEventListener( 'resize', onWindowResize, false );

			}
			
			
			var lastTimeMsec= null
			function animate( nowMsec )
			{
				
				// measure time
				lastTimeMsec	= lastTimeMsec || nowMsec-1000/60
				var deltaMsec	= Math.min(200, nowMsec - lastTimeMsec)
				lastTimeMsec	= nowMsec
				
				earth.animate( deltaMsec/1000, nowMsec/1000 );
				
				test_net.animate();
				// dune.animate();
				

				requestAnimationFrame( animate );
				
				TWEEN.update();
				stats.update();
				render();

			}
			
//			 function onWindowResize() {

// 				camera.aspect = window.innerWidth / window.innerHeight;
// 				camera.updateProjectionMatrix();

// 				renderer.setSize( window.innerWidth, window.innerHeight );

// 			}
			
			function onDocumentTouchStart( event ) {
				
				event.preventDefault();
				
				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );

			}	

			function onDocumentMouseDown1( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( group.children );

				if ( intersects.length > 0 ) {
					
					selectMember( intersects[ 0 ].object );
					
					console.log( intersects[ 0 ].object );

				}

				/*
				// Parse all the faces
				for ( var i in intersects ) {

					intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

				}
				*/
			}
			
			function onDocumentMouseMove( event ) {
			
				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				if ( SELECTED ) {

					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

						SELECTED.body.position.copy( intersection.sub( offset ) );
				// 		debugger;
				// 		SELECTED.certifications
				// 			.map( cert => {
	// 							cert.line.geometry.vertices[1].copy( SELECTED.position )
	// 							cert.line.geometry.computeLineDistances();
	// 							cert.line.geometry.verticesNeedUpdate = true;
	// 						});
				// 		SELECTED.madeCertifications
				// 			.map( cert => {
	// 							cert.line.geometry.vertices[0].copy( SELECTED.position )
	// 							cert.line.geometry.computeLineDistances();
	// 							cert.line.geometry.verticesNeedUpdate = true;
	// 						});

					}

					return;

				}

				var intersects = raycaster.intersectObjects( dune.children );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

						plane.setFromNormalAndCoplanarPoint(
							camera.getWorldDirection( plane.normal ),
							INTERSECTED.position );

					}

					container.style.cursor = 'pointer';

				} else {

					if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

					container.style.cursor = 'auto';

				}

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();
				
				mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;
				
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( dune.children );

				if ( intersects.length > 0 && !(intersects[ 0 ] instanceof Interaction) ) {

					controls.enabled = false;
					
					// dune.members.filter( guy => guy.selected ).map( guy => guy.deselect() )
					SELECTED = intersects[ 0 ].object;
				// 	SELECTED.selected ? SELECTED.deselect() : SELECTED.select();
					
					console.log( SELECTED );

					if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

						offset.copy( intersection ).sub( SELECTED.position );

					}

					container.style.cursor = 'move';

				}

			}

			function onDocumentMouseUp( event ) {

				event.preventDefault();

				controls.enabled = true;

				if ( INTERSECTED ) {

					SELECTED = null;

				}

				container.style.cursor = 'auto';

			}
			
			var frame = 0;
			function render() {

				frame ++;
				var time = Date.now() * 0.001;
				
				// dune._boundingBox.geometry &&
				// dune._boundingBox.geometry.boundingSphere &&
				// dune._boundingBox.geometry.boundingSphere.center &&
				//	 camera.lookAt( dune._boundingBox.geometry.boundingSphere.center );
				// camera.lookAt( MedianPosition( dune.children.filter( c => c instanceof Account ) ) );
				// group.rotation.y = time * 0.1;
				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
